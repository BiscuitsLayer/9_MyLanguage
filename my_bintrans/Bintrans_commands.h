//REGISTERS
//size = 1
#define _RAX 0b00000000
#define _RCX 0b00000001
#define _RDX 0b00000010
#define _RBX 0b00000011
#define _RSP 0b00000100
#define _RBP 0b00000101
#define _RSI 0b00000110
#define _RDI 0b00000111

//MINIREGISTERS
#define _AL 0b00000000
#define _CL 0b00000001
#define _DL 0b00000010
#define _BL 0b00000011
#define _AH 0b00000100
#define _CH 0b00000101
#define _BH 0b00000110
#define _DH 0b00000111

//PROREGISTERS
//size = 1
#define _R8 0b00000000
#define _R9 0b00000001
#define _R10 0b00000010
#define _R11 0b00000011
#define _R12 0b00000100
#define _R13 0b00000101
#define _R14 0b00000110
#define _R15 0b00000111

//MATH
//size = 7
#define _ADD_R_N(REG, NUM) 0b01001000, 0b10000001, 0b11000000 | REG, ((NUM) & 0x000000FF), ((NUM) & 0x0000FF00) >> 8, ((NUM) & 0x00FF0000) >> 16, ((NUM) & 0xFF000000) >> 24
#define _SUB_R_N(REG, NUM) 0b01001000, 0b10000001, 0b11101000 | REG, ((NUM) & 0x000000FF), ((NUM) & 0x0000FF00) >> 8, ((NUM) & 0x00FF0000) >> 16, ((NUM) & 0xFF000000) >> 24
//size = 3
#define _INC_R(REG) 0b01001000, 0b11111111, 0b11000000 | REG
#define _DEC_R(REG) 0b01001000, 0b11111111, 0b11001000 | REG
#define _INC_PROR(PROREG) 0b01001001, 0b11111111, 0b11000000 | PROREG
#define _DEC_PROR(PROREG) 0b01001001, 0b11111111, 0b11001000 | PROREG
#define _ADD_R_R(REG1, REG2) 0b01001000, 0b00000001, 0b11000000 | REG1 | (REG2 << 3)
#define _ADD_R_PROR(REG, PROREG) 0b01001100, 0b00000001, 0b11000000 | REG | (PROREG << 3)
#define _SUB_R_R(REG1, REG2) 0b01001000, 0b00101001, 0b11000000 | REG1 | (REG2 << 3)
#define _SUB_MINIR_N(MINIREG, NUM) 0b10000000, 0b11101000 | MINIREG, ((NUM) & 0x000000FF)
#define _IMUL(REG) 0b01001000, 0b11110111, 0b11101000 | REG
#define _IDIV(REG) 0b01001000, 0b11110111, 0b11111000 | REG

//SYSTEM
//size = 5
#define _CALL_LEN 5
#define _CALL(OFFSET) 0b11101000, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
//size = 2
#define _SYSCALL 0b00001111, 0b00000101
#define _INT_0x80 0b11001101, 0b10000000
//size = 1
#define _RET 0b11000011

//STACK
//size = 7
#define _PUSH_M(MEM) 0b11111111, 0b00110100, 0b00100101, ((MEM) & 0x000000FF), ((MEM) & 0x0000FF00) >> 8, ((MEM) & 0x00FF0000) >> 16, ((MEM) & 0xFF000000) >> 24
#define _POP_M(MEM) 0b10001111, 0b00000100, 0b00100101, ((MEM) & 0x000000FF), ((MEM) & 0x0000FF00) >> 8, ((MEM) & 0x00FF0000) >> 16, ((MEM) & 0xFF000000) >> 24
//size = 5
#define _PUSH_N(NUM) 0b01101000, ((NUM) & 0x000000FF), ((NUM) & 0x0000FF00) >> 8, ((NUM) & 0x00FF0000) >> 16, ((NUM) & 0xFF000000) >> 24
//size = 3
#define _PUSH_MR_N(REG, NUM) 0b11111111, 0b01110000 | REG, (((256 + (NUM)) % 256) & 0x000000FF)
#define _POP_MR_N(REG, NUM) 0b10001111, 0b01000000 | REG, (((256 + (NUM)) % 256) & 0x000000FF)
//size = 2
#define _PUSH_PROR(REG) 0b01000001, 0b01010000 | REG
#define _POP_PROR(PROREG) 0b01000001, 0b01011000 | PROREG
//size = 1
#define _PUSH_R(REG) 0b01010000 | REG
#define _POP_R(REG) 0b01011000 | REG


//MEMORY
//size = 8
#define _MOV_M_R(MEM, REG) 0b01001000, 0b10001001, 0b00000100, 0b00100101 | (REG << 3), ((MEM) & 0x000000FF), ((MEM) & 0x0000FF00) >> 8, ((MEM) & 0x00FF0000) >> 16, ((MEM) & 0xFF000000) >> 24
//size = 7
#define _MOV_R_M(REG, MEM) 0b01001000, 0b11000111, 0b11000000 | REG, ((MEM) & 0x000000FF), ((MEM) & 0x0000FF00) >> 8, ((MEM) & 0x00FF0000) >> 16, ((MEM) & 0xFF000000) >> 24
#define _MOV_R_N(REG, NUM) 0b01001000, 0b11000111, 0b11000000 | REG, ((NUM) & 0x000000FF), ((NUM) & 0x0000FF00) >> 8, ((NUM) & 0x00FF0000) >> 16, ((NUM) & 0xFF000000) >> 24
//size = 4
#define _MOV_MR_N_R(REG1, NUM, REG2) 0b01001000, 0b10001001, 0b01000000 | REG1 | (REG2 << 3), (((256 + (NUM)) % 256) & 0x000000FF)
#define _MOV_R_MR_N(REG1, REG2, NUM) 0b01001000, 0b10001011, 0b01000000 | REG2 | (REG1 << 3), (((256 + (NUM)) % 256) & 0x000000FF)
//size = 3
#define _MOV_BYTEMR_N(REG, NUM) 0b11000110, 0b00000000 | REG, ((NUM) & 0x000000FF)
#define _MOV_MINIR_BYTEMR(MINIREG, REG) 0b01100111, 0b10001010, 0b00000000 | REG | (MINIREG << 3)
#define _MOV_R_R(REG1, REG2) 0b01001000, 0b10001001, 0b11000000 | REG1 | (REG2 << 3)
#define _XCHG_R_R(REG1, REG2) 0b01001000, 0b10000111, 0b11000000 | REG1 | (REG2 << 3)
//size = 2
#define _MOV_MINIR_N(MINIREG, NUM) 0b10110000 | MINIREG, ((NUM) & 0x000000FF)
#define _MOV_MR_MINIR(REG, MINIREG) 0b10001000, 0b00000000 | REG | (MINIREG << 3)

//LOGIC
//size = 7
#define _TEST_R_N(REG, NUM) 0b01001000, 0b11110111, 0b11000000 | REG, ((NUM) & 0x000000FF), ((NUM) & 0x0000FF00) >> 8, ((NUM) & 0x00FF0000) >> 16, ((NUM) & 0xFF000000) >> 24
#define _CMP_R_N(REG, NUM) 0b01001000, 0b10000001, 0b11111000 | REG, ((NUM) & 0x000000FF), ((NUM) & 0x0000FF00) >> 8, ((NUM) & 0x00FF0000) >> 16, ((NUM) & 0xFF000000) >> 24
//size = 4
#define _CMP_PROR_N(PROREG, NUM) 0b01001001, 0b10000011, 0b11111000 | PROREG, ((NUM) & 0x000000FF)
//size = 3
#define _NEG_R(REG) 0b01001000, 0b11110111, 0b11011000 | REG
#define _XOR_R_R(REG1, REG2) 0b01001000, 0b00110001, 0b11000000 | REG1 | (REG2 << 3)
#define _XOR_PROR_PROR(PROREG1, PROREG2) 0b01001101, 0b00110001, 0b11000000 | PROREG1 | (PROREG2 << 3)
#define _TEST_R_R(REG1, REG2) 0b01001000, 0b10000101, 0b11000000 | REG1 | (REG2 << 3)
#define _TEST_PROR_PROR(PROREG1, PROREG2) 0b01001101, 0b10000101, 0b11000000 | PROREG1 | (PROREG2 << 3)
#define _CMP_R_R(REG1, REG2) 0b01001000, 0b00111001, 0b11000000 | REG1 | (REG2 << 3)
#define _CMP_MINIR_N(MINIREG, NUM) 0b10000000, 0b11111000 | MINIREG, ((NUM) & 0x000000FF)

//JUMPS
//size = 6
#define _J_COND_LEN 6
#define _JE(OFFSET) 0b00001111, 0b10000100, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JZ(OFFSET) 0b00001111, 0b10000100, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JNE(OFFSET) 0b00001111, 0b10000101, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JNZ(OFFSET) 0b00001111, 0b10000101, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JG(OFFSET) 0b00001111, 0b10001111, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JGE(OFFSET) 0b00001111, 0b10001101, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JL(OFFSET) 0b00001111, 0b10001100, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JLE(OFFSET) 0b00001111, 0b10001110, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JS(OFFSET) 0b00001111, 0b10001000, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
#define _JNS(OFFSET) 0b00001111, 0b10001001, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24
//size = 5
#define _JUMP_LEN 5
#define _JMP(OFFSET) 0b11101001, ((OFFSET) & 0x000000FF), ((OFFSET) & 0x0000FF00) >> 8, ((OFFSET) & 0x00FF0000) >> 16, ((OFFSET) & 0xFF000000) >> 24

//SQRT
//size = 3
#define _FINIT 0b10011011, 0b11011011, 0b11100011
//size = 2
#define _FILD_MR(REG) 0b11011111, 0b00101000 | REG //Вместо указателя на память значение регистра
#define _FSQRT 0b11011001, 0b11111010
#define _FISTP_MR(REG) 0b11011111, 0b00111000 | REG //Вместо указателя на память значение регистра

//Разберись с section test И data